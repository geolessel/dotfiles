#+TITLE: Geo's emacs config
#+AUTHOR: Geoffrey Lessel

* Startup

Things that need to happen right away.

** Increase garbage collector threshold
   The default is 800kB and increasing it will speed up startup time.
   Before we're done with the config though, we need to put it back down.

    #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold 10000000)
      ;; restore after startup
      (add-hook 'after-init-hook
        (lambda ()
          (setq gc-cons-threshold 1000000)
            (message "gc-cons-threshold restored to %S" gc-cons-threshold)))
    #+END_SRC

** Bootstrap `straight` package manager
    #+BEGIN_SRC emacs-lisp
    (defvar bootstrap-version)
    (let
    ((bootstrap-file
    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
    (bootstrap-version 5))
    (unless
    (file-exists-p bootstrap-file)
    (with-current-buffer
    (url-retrieve-synchronously
                "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
                'silent 'inhibit-cookies)
    (goto-char
    (point-max))
    (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
    #+END_SRC

** `use-package`
    #+BEGIN_SRC emacs-lisp
    (straight-use-package 'use-package)
    #+END_SRC

*** Syntax example
    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package package-name      ; use the package package-name
      :straight t                  ; use straight to manage it
      :init                        ; execute code BEFORE package load
      (setq foo-variable t)
      :config                      ; execute code AFTER package load
      (foo-mode 1)
    )
    #+END_SRC

*** Always install a package if it's not available
    #+BEGIN_SRC emacs-lisp
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+END_SRC


* Emacs general system settings

Configurations around Emacs itself (i.e. not from a package).

** Don't show startup message
    #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t)
    #+END_SRC

** Specify backup directory
    #+BEGIN_SRC emacs-lisp
    (setq backup-directory-alist
      '(("." . "~/.emacs-backups"))
      backup-by-copying t   ; don't delink hardlinks
      version-control t     ; use version numbers on backups
      delete-old-versions t ; automatically delete excess backups
      kept-new-versions 20  ; how many of the newest versions to keep
      kept-old-versions 5   ; how many of the old versions to keep
      )
    #+END_SRC

** Use a custom location for "customize" settings

   #+BEGIN_SRC emacs-lisp
   (setq custom-file "~/.emacs.d/custom.el")
   (load custom-file)
   #+END_SRC

** Hide the toolbar
    #+BEGIN_SRC emacs-lisp
    (tool-bar-mode -1)
    #+END_SRC

** Hide the menu bar

    #+BEGIN_SRC emacs-lisp
    (menu-bar-mode -1)
    #+END_SRC

** Hide the scroll bar

    #+BEGIN_SRC emacs-lisp
    (scroll-bar-mode -1)
    #+END_SRC

** Show the fill-line column indicator

   Set the column to show it at with =set-fill-column=.

   #+begin_src emacs-lisp
   (setq global-display-fill-column-indicator-mode t)
   #+end_src

** Show the matching parens

    #+BEGIN_SRC emacs-lisp
    (show-paren-mode 1)
    #+END_SRC

    If the matching paren isn't visible, highlight the entire
    expression.

    #+begin_src emacs-lisp
    (setq show-paren-style "mixed")
    #+end_src

** Set the default tab width

    #+BEGIN_SRC emacs-lisp
    (setq-default tab-width 2)
    #+END_SRC

** Always use spaces for tabs

    #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)
    #+END_SRC

** Turn off the error bell

    #+BEGIN_SRC emacs-lisp
    (setq ring-bell-function 'ignore)
    #+END_SRC

** Make the yes/no prompts accept y/n

    #+BEGIN_SRC emacs-lisp
    (defalias 'yes-or-no-p 'y-or-n-p)
    #+END_SRC

** Always delete trailing whitespace

    #+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook 'delete-trailing-whitespace)
    #+END_SRC

** Turn on the column display in the modeline

   Sometimes errors report the column as well as the line. So let's
   view the column number we are on!

   #+begin_src emacs-lisp
   (column-number-mode)
   #+end_src

** Highlight the current line

   I like to know where I am.

   #+begin_src emacs-lisp
   (global-hl-line-mode t)
   #+end_src


* UI

** Themes
   Doom emacs has some great themes. Let's use them!

    #+BEGIN_SRC emacs-lisp
    (use-package doom-themes
      :straight t)
    #+END_SRC

   Here is the theme to load for this session.

    #+BEGIN_SRC emacs-lisp
    (load-theme 'doom-one-light t) ; t treats it as safe
    #+END_SRC

** Font

   When you have the best font, use the best font.

   #+BEGIN_SRC emacs-lisp
   (set-frame-font "PragmataPro Liga-14" nil t)
   #+END_SRC

   Turn on ligature support in the emacs-mac build.

   #+BEGIN_SRC emacs-lisp
   (mac-auto-operator-composition-mode t)
   #+END_SRC

** Modeline

   Doom emacs also provides a pretty slick mode line. Let's use that, too.

    #+BEGIN_SRC emacs-lisp
    (use-package doom-modeline
      :straight t
      :hook
      (after-init . doom-modeline-mode)
      :config
      ; use unicode as a fallback (instead of ASCII) when not using icons
      (setq doom-modeline-unicode-fallback t)

      ; don't display the buffer encoding
      (setq doom-modeline-buffer-encoding nil)

      ;; Determines the style used by `doom-modeline-buffer-file-name'.
      ;; Given ~/Projects/FOSS/emacs/lisp/comint.el
      ;;   auto => emacs/lisp/comint.el (in a project) or comint.el
      ;;   truncate-upto-project => ~/P/F/emacs/lisp/comint.el
      ;;   truncate-from-project => ~/Projects/FOSS/emacs/l/comint.el
      ;;   truncate-with-project => emacs/l/comint.el
      ;;   truncate-except-project => ~/P/F/emacs/l/comint.el
      ;;   truncate-upto-root => ~/P/F/e/lisp/comint.el
      ;;   truncate-all => ~/P/F/e/l/comint.el
      ;;   truncate-nil => ~/Projects/FOSS/emacs/lisp/comint.el
      ;;   relative-from-project => emacs/lisp/comint.el
      ;;   relative-to-project => lisp/comint.el
      ;;   file-name => comint.el
      ;;   buffer-name => comint.el<2> (uniquify buffer name)
      ;;
      ;; If you are experiencing the laggy issue, especially while editing remote files
      ;; with tramp, please try `file-name' style.
      ;; Please refer to https://github.com/bbatsov/projectile/issues/657.
      (setq doom-modeline-buffer-file-name-style 'truncate-with-project)
      )
    #+END_SRC

** Dashboard

   Doom emacs has a great startup dashboard. Let's use it!

    #+BEGIN_SRC emacs-lisp
    (use-package dashboard
      :straight t
      :config
      (dashboard-setup-startup-hook)
      ; set the title
      (setq dashboard-banner-logo-title "Greetings Geo. Shall we play a game?")
      ; set the banner
      (setq dashboard-startup-banner 'logo)
      ; set the sections I'd like displayed and how many of each
      (setq dashboard-items '((recents . 5) (projects . 5)))
      ; center it all
      (setq dashboard-center-content t)
      ; don't show shortcut keys
      (setq dashboard-show-shortcuts nil)
      ; use nice icons for the files
      (setq dashboard-set-file-icons t)
      ; use nice section icons
      (setq dashboard-set-heading-icons t)
      ; disable the snarky footer
      (setq dashboard-set-footer nil))
    #+END_SRC

** Visualizations
*** Display a visual hint when editing with *evil-goggles*.

   #+BEGIN_SRC emacs-lisp
   (use-package evil-goggles
     :straight t
     :after (evil)
     :config
     (evil-goggles-mode)
     )
   #+END_SRC

** Workspaces

   I can use this to work in one project in one perspective/workspace
   and others kept open in other perspectives. After some looking and
   reading, I've decided on `perspective`.

   - [[https://github.com/nex3/perspective-el][Github]]

   Some alternatives I considered:

   - [[https://github.com/Bad-ptr/persp-mode.el][persp-mode]] - a fork of =perspective= and used by Doom Emacs. It is
     possible it will be merged with =perspective= at some point. After
     trying to get keybinding working and failing after a while, I gave up
     on it and preferred =perspective= for its more informative README.
   - [[https://github.com/wasamasa/eyebrowse][eyebrowse]] - supports window layounts but no buffer lists. After I gave
     up on =persp-mode= this was initially my preference.

   #+begin_src emacs-lisp
   (use-package perspective
     :straight t
     :config
     (persp-mode)
     ; sort perspectives by most recently accessed (others: 'name, 'created)
     (setq persp-sort 'access)
     )
   #+end_src


* Modes

** Evil mode

   Make it like vim!

    #+BEGIN_SRC emacs-lisp
    (use-package evil
      :straight t
      ; :after (evil-leader) ; must be after to get leader available in initial buffers
      :init
      (setq evil-want-integration t)
      (setq evil-want-keybinding nil)
      (setq evil-want-C-u-scroll t) ; use Ctrl-U to scroll up
      :config
      (evil-mode 1)) ; use evil-mode everywhere
    #+END_SRC


*** Extra keybindings
    A collection of Evil bindings for the parts of Emacs that Evil does not
    cover properly by default, such as help-mode, M-x calendar, Eshell and more.

    #+BEGIN_SRC emacs-lisp
    (use-package evil-collection
      :straight t
      ; :after (evil evil-leader)
      :init
      (setq evil-want-keybinding nil)
      :config
      (evil-collection-init))
    #+END_SRC

** YAML mode

   #+begin_src emacs-lisp
   (use-package yaml-mode
     :straight t
     :config
     (add-to-list 'auto-mode-alist '("\\.ya?ml$" . yaml-mode))
     )
   #+end_src

** Org mode

   Some little things to make =org-mode= better.

*** Show bullets as utf-8 characters

    #+begin_src emacs-lisp
    (use-package org-bullets
      :straight t)
    #+end_src

** JS mode

   The default for =js-mode= is to indent at 4 spaces. NOPE.

   #+begin_src emacs-lisp
   (setq js-indent-level 2)
   #+end_src


* Editing

  Things that provide general, non-language specific editing functionality.


** Moving and navigating the buffer

    With *evil-easymotion* you can invoke =M=, and this plugin will put a
    target character on every possible position. Type the character on the
    target and wham! you have teleported there.

    #+BEGIN_SRC emacs-lisp
    (use-package evil-easymotion
          :straight t
          :after (evil)
          :config
    (evilem-default-keybindings "M")
    )
    #+END_SRC

    *=evil-snipe=* emulates =vim-seek= and/or =vim-sneak= in
    =evil-mode=.  It provides 2-character motions for quickly (and
    more accurately) jumping around text, compared to evil's built-in
    f/F/t/T motions, incrementally highlighting candidate targets as
    you type.

    #+BEGIN_SRC emacs-lisp
    (use-package evil-snipe
          :straight t
          :after (evil)
          :config
      (evil-snipe-mode +1)
      ; binds `s`/`S` (forward/backward)
      (evil-snipe-override-mode +1)
      ; binds `f`, `F`, `t`, `T` overrides
      (setq evil-snipe-scope 'visible)
      ; highlights all forward matches in visible buffer
    )
    #+END_SRC

** Projects

*** Use *projectile* to manage projects.

   - [[https://projectile.mx/][Home page]]
   - [[https://docs.projectile.mx/projectile/index.html][Manual]]

   #+BEGIN_SRC emacs-lisp
   (use-package projectile
     :straight t
     :bind-keymap
     ("C-c p" . projectile-command-map)
     :config
     (projectile-mode +1))
   #+END_SRC

*** Group buffers by project

    Sometimes it's helpful to see the buffers open grouped by project.
    We can use *ibuffer-projectile* to do that.

    - [[https://github.com/purcell/ibuffer-projectile][Github]]

    #+BEGIN_SRC emacs-lisp
    (use-package ibuffer-projectile
      :straight t
      :config
      (add-hook 'ibuffer-hook
        (lambda ()
          (ibuffer-projectile-set-filter-groups)
          (unless (eq ibuffer-sorting-mode 'alphabetic)
            (ibuffer-do-sort-by-alphabetic)))))
    #+END_SRC

** Commenting

    A Nerd Commenter emulation, help you comment code efficiently. For example,
    you can press =99,ci= to comment out 99 lines.

    Examples:

    - `,ci` comments the current line

    The docs recommend calling ~evilnc-default-hotkeys~ on load to set up
    the keybindings. However, this sets ~C-c p~ which I prefer to save
    for =projectile=.

    [[https://github.com/redguardtoo/evil-nerd-commenter][Github]]

    #+BEGIN_SRC emacs-lisp
    (use-package evil-nerd-commenter
      :straight t
      :after evil
      :bind (
        ("C-c c ;" . evilnc-comment-or-uncomment-lines)
        ("C-c c l" . evilnc-quick-comment-or-uncomment-to-the-line)
        ("C-c c p" . evilnc-comment-or-uncomment-paragraphs)))
    #+END_SRC

** Aligning

   *=evil-lion=* provides =gl= and =gL= align operators: ~gl MOTION CHAR~ and right-align ~gL MOTION CHAR~.
   Use ~CHAR /~ to enter regular expression if a single character wouldn't suffice.
   Use ~CHAR RET~ to align with align.el's default rules for the active major mode.

    #+BEGIN_SRC emacs-lisp
(use-package evil-lion
      :straight t
      :bind
(:map evil-normal-state-map
("g l " . evil-lion-left)
("g L " . evil-lion-right)
:map evil-visual-state-map
("g l " . evil-lion-left)
("g L " . evil-lion-right)))
#+END_SRC

** Change text surrounding selection

   *=evil-surround-mode=* emulates surround.vim by Tim Pope.
   Surround.vim is all about "surroundings": parentheses, brackets, quotes, XML tags, and more. The
   plugin provides mappings to easily delete, change and add such surroundings in pairs.

   It's easiest to explain with examples.

   1. Press ~cs"'~ inside ="Hello world!"= to change it to ='Hello world!'=
   2. Now press ~cs'<q>~ to change it to =<q>Hello world!</q>=
   3. To go full circle, press ~cst"~ to get ="Hello world!"=
   4. To remove the delimiters entirely, press ~ds"~. =Hello world!=
   5. Now with the cursor on ="Hello"=, press ~ysiw]~ (~iw~ is a text object). =[Hello] world!=
   6. Let's make that braces and add some space (use ~}~ instead of ~{~ for no space): ~cs]{~ ={ Hello } world!=
   7. Now wrap the entire line in parentheses with ~yssb~ or ~yss)~. =({ Hello } world!)=
   8. Revert to the original text: ~ds{ds)~ =Hello world!=
   9. Emphasize hello: ~ysiw<em>~ =<em>Hello</em> world!=

    #+BEGIN_SRC emacs-lisp
    (use-package evil-surround
      :straight t
      :after evil
      :config
      (global-evil-surround-mode 1))
    #+END_SRC

** Version control (git)

   *magit* of course.

   - [[https://github.com/magit/magit][Github]]
   - [[https://magit.vc/manual/][Manual]]

   #+BEGIN_SRC emacs-lisp
   (use-package magit
     :straight t
     :bind (
       ("C-c g" . magit-status)))
   #+END_SRC

   Highlight changed lines with *diff-hl*. The changes are
   shown via indicators on the fringe but don't refresh/update
   until a save has occurred.

   - [[https://github.com/dgutov/diff-hl/][Github]]

   #+BEGIN_SRC emacs-lisp
   (use-package diff-hl
     :straight t
     :config
     (global-diff-hl-mode))
   #+END_SRC

** Buffers

   Group buffers in ibuffer list by projectile project with *ibuffer-projectile*.

   - [[https://github.com/purcell/ibuffer-projectile][Github]]

   #+BEGIN_SRC emacs-lisp
   (use-package ibuffer-projectile
     :straight t
     :config
     (add-hook 'ibuffer-hook
       (lambda ()
         (ibuffer-projectile-set-filter-groups)
         (unless (eq ibuffer-sorting-mode 'alphabetic)
           (ibuffer-do-sort-by-alphabetic)))))
   #+END_SRC

   Kill other buffers except the current one. Taken from the [[https://www.emacswiki.org/emacs/KillingBuffers#toc2][Emacs
   Wiki]] with modifications from [[https://stackoverflow.com/questions/3417438/close-all-buffers-besides-the-current-one-in-emacs][Stack Overflow]]. The modifications make
   it so that if the buffer is from something other than visiting a
   file (e.g. =*scratch*= or =*Messages*=), it will stick around.

   #+begin_src emacs-lisp
   (defun geo/kill-other-buffers ()
     "Kill all other buffers."
     (interactive)
     (mapc 'kill-buffer
       (delq (current-buffer)
             (remove-if-not 'buffer-file-name (buffer-list)))))
   #+end_src

** Undo

   Even I make mistakes. Emacs' built-in undo system is pretty powerful
   but a little hard to understand. There are other undo packages that
   dumb it down at the expense of functionality, but *undo-tree* tries
   to make that power come easier, especially with tree visualization.

   The documentation for this one (with examples) is in the source code.

   - [[https://www.dr-qubit.org/undo-tree.html][Homepage]]

   #+BEGIN_SRC emacs-lisp
   (use-package undo-tree
     :straight t
     :config
     (global-undo-tree-mode)          ; use it everwhere!
     ;; (setq evil-undo-system 'undo-tree)
     )
   #+END_SRC

** Snippets

   Make repetitive work faster by using snippets! This uses the
   *yasnippet* package. There are libraries out there that contain
   snippets for all sorts of situations (like [[http://github.com/AndreaCrotti/yasnippet-snippets][yasnippet-snippets]], but
   I prefer to make my own when I need them.

   - [[https://github.com/joaotavora/yasnippet][Github]]

   Stuff I forget and need to be reminded of regularly:

   - ~name~ is the description of the snippet
   - ~key~ is the snippet abbreviation
   - ~$1~ is the first tab stop field
   - ~$0~ is the exit point of the snippet
   - ~${1:default}~ sets a default value

   #+begin_src emacs-lisp
   (use-package yasnippet
     :straight t
     :config
     (yas-global-mode 1)
     )
   #+end_src


* General packages

Things that I couldn't think of a better top-level heading for.

** Packages that provide some help

*** Show available keys for a mode in a popup

    Using *which-key*.

    - [[https://github.com/justbur/emacs-which-key][Github]]

    #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :straight t
      :config
      (which-key-mode))
    #+END_SRC

*** An alternative built-in help system

    *helpful* is an alternative to the built-in Emacs help that
    provides much more contextual information.

    - [[https://github.com/Wilfred/helpful][Github]]

    #+BEGIN_SRC emacs-lisp
    (use-package helpful
      :straight t
      :bind (
        ; rebind help keys to use helpful
        ("C-h f" . helpful-callable)
        ("C-h v" . helpful-variable)
        ("C-h k" . helpful-key)
        ; lookup the current symbol at point
        ("C-c C-d" . helpful-at-point)
        ; look up functions (expluding macros)
        ("C-h F" . helpful-function)
        ; look up commands
        ("C-h C" . helpful-command))
      :config
      ; use helpful with ivy
      (setq counsel-describe-function-function #'helpful-callable)
      (setq counsel-describe-variable-function #'helpful-variable))
    #+END_SRC

** Searching

   I've always enjoyed =ag= as my searcher of choice. Let's get it
   into Emacs.

   #+begin_src emacs-lisp
   (use-package ag
     :straight t
     :config
     (setq ag-highlight-search t) ; highlight results
     )
   #+end_src

** Make the minibuffer better

*** Select from a list with Ivy and Counsel

    *ivy* is for quick and easy selection from a list. It
    is provided in the =counsel= package along with =swiper=.

    - [[https://oremacs.com/swiper/][Documentation]]
    - [[https://github.com/abo-abo/swiper][Github]]

    #+BEGIN_SRC emacs-lisp
    (use-package counsel
      :straight t
      :config
      (ivy-mode t)      ; enable ivy-mode everywhere
      (counsel-mode t)  ; enable counsel mode replacements
      (setq ivy-use-virtual-buffers t)
      (setq ivy-count-format "(%d/%d) ")
      (setq ivy-initial-inputs-alist nil)) ; don't start the search with ~^~
    #+END_SRC

**** Make =ivy= prettier

     *ivy-rich* has rich transformers for commands from =ivy= and =counsel=.
     You can defined your own transformers too.

     [[https://github.com/yevgnen/ivy-rich][Github]]

     #+BEGIN_SRC emacs-lisp
     (use-package ivy-rich
       :straight t
       :after (ivy counsel)
       :config
       (ivy-rich-mode 1)
       ; the docs recommend to set this as well
       (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line))
     #+END_SRC

**** Use fuzzy finding for counsel

     We have two good choices for filtering results. The first is
     =flx= and the second is =prescient=.

     Use *=prescient=* to sort and filter a list of candidates.

     prescient.el takes as input a list of candidates, and a query
     that you type. The query is first split on spaces into subqueries
     (two consecutive spaces match a literal space). Each subquery
     filters the candidates because it must match as either a
     substring of the candidate, a regexp, or an initialism
     (e.g. ffap matches find-file-at-point, and so does fa). The last
     few candidates you selected are displayed first, followed by the
     most frequently selected ones, and then the remaining candidates
     are sorted by length. If you don't like the algorithm used for
     filtering, you can choose a different one by customizing
     prescient-filter-method.

     - [[https://github.com/raxod502/prescient.el][Github]]

     #+BEGIN_SRC emacs-lisp
     (use-package prescient :straight t)
     (use-package ivy-prescient
       :straight t
       :after (ivy counsel prescient)
       :config
       (ivy-prescient-mode t)
       ; describe-variable prescient-filter-method for docs
       (setq prescient-filter-method '(literal regexp fuzzy initialism)))
     #+END_SRC

*** Replace M-x with Amx

    *=amx=* is an alternative interface for ~M-x~ in Emacs. Some
    enhancements include prioritizing your most-used commands in the
    completion list and showing keyboard shortcuts.

    - [[https://github.com/DarwinAwardWinner/amx][Github]]

    Some tips:
    - ~C-h f~ while Amx is active runs ~describe-function~ on the currently
      selected command
    - ~M-.~ jumps to the definition of the selected command
    - ~C-h w~ shows the key bindings for the selected command
    - ~amx-major-mode-commands~ runs Amx limited to commands that are relevant
      to the active major mode.
    - ~amx-show-unbound-commands~ shows frequently used commands that have
      no keybindings.

    #+BEGIN_SRC emacs-lisp
    (use-package amx
      :straight t
      :after (ivy counsel)
      :config
      (amx-mode t))   ; it auto-detects ivy-mode
    #+END_SRC



*** Use hydra for extra context/help

    *hydra* can provide custom menus to describe keybinds and such.

    - [[https://github.com/abo-abo/hydra][Github]]

    #+begin_src emacs-lisp
    (use-package hydra
      :straight t
      )
    #+end_src

    *pretty-hydra* makes it easy to define pretty hydras! It takes
    away a lot of the manual try-and-reload usually required to define
    nice docstrings.

    - [[https://github.com/jerrypnz/major-mode-hydra.el#pretty-hydra][Github]]

    #+begin_src emacs-lisp
    (use-package pretty-hydra
      :straight t
      )
    #+end_src

** Better terminal emulation

   I've heard that *vterm* is the bee's knees.

   - [[https://github.com/akermu/emacs-libvterm][Github]]

   #+begin_src emacs-lisp
   (use-package vterm
     :straight t
     :init
     (setq vterm-always-compile-module t))
   #+end_src


* Personal keybindings

  Make it mine.

** Buffer/window management

   #+BEGIN_SRC emacs-lisp
   ; (evil-leader/set-key
   ;   "b b" 'counsel-switch-buffer
   ;   "b i" 'ibuffer
   ;   ; "TAB s" 'persp-switch          ; query a persp to switch to or create
   ;   ; "TAB n" 'persp-switch
   ;   ; "TAB c" 'persp-kill            ; query a persp to kill
   ;   ; "TAB r" 'persp-rename          ; rename current perspective
   ;   ; "TAB i" 'persp-import          ; import a persp from another frame
   ;   ; "TAB <right>" 'persp-next      ; switch to next perspective
   ;   ; "TAB <left>" 'persp-prev       ; switch to previous perspective
   ;   ; "TAB w" 'persp-state-save      ; save all persps in all frames to a file
   ;   ; "TAB l" 'persp-state-load      ; load all persps from a file
   ;   ; "TAB b k" 'persp-remove-buffer ; query a buffer to remove from current persp
   ;   ; "TAB b a" 'persp-add-buffer    ; query and open buffer to add to current persp
   ;   ; "TAB b s" 'persp-set-buffer    ; move buffer to current persp
   ;   ; "TAB b b" 'persp-counsel-switch-buffer ; swicth to buffer filtered by current persp
   ;   )
   #+END_SRC

** Project management

   #+BEGIN_SRC emacs-lisp
   ; (evil-leader/set-key
   ;   "p" 'projectile-command-map
   ;   )
   #+END_SRC

** Version control

   #+BEGIN_SRC emacs-lisp
   ; (evil-leader/set-key
   ;   "g" 'magit-status
   ;   )
   #+END_SRC

** Editing tasks
*** Search with =counsel-ag=

    Since ~/~ is search in =evil-mode=, I like binding ~C-/~ to search
    the entire project.

    I have to wrap =counsel-ag= with a ~let~ in order to restrict
    which completion modes are available to ag. I want to either be
    specific (~literal~) or be able to input a regex (`regexp`).

    #+begin_src emacs-lisp
    (defun geo/counsel-ag ()
      (interactive)
      (let* ((prescient-filter-method '(literal regexp)))
        (counsel-ag)))

    (define-key evil-normal-state-map (kbd "C-/") 'geo/counsel-ag)
    #+end_src

** Hydra menus

*** Apropros

   #+begin_src emacs-lisp
   (defhydra geo/hydra-apropos-menu (:color blue :hint nil)
"
_a_propos        _c_ommand
_d_ocumentation  _l_ibrary
_v_ariable       _u_ser-option
_i_nfo       valu_e_"
   ("a" counsel-apropos)
   ("d" apropos-documentation)
   ("v" apropos-variable)
   ("i" info-apropos)
   ("c" apropos-command)
   ("l" apropos-library)
   ("u" apropos-user-option)
   ("e" apropos-value))
   #+end_src

*** Workspaces

   #+begin_src emacs-lisp
   (pretty-hydra-define geo/hydra-workspace-menu (:exit t :quit-key "q")
     ("General"
       (("s" persp-switch "Switch/New")
        ("k" persp-kill "Kill")
        ("r" persp-rename "Rename")
        ("i" persp-import "Import")
        ("n" persp-next "Next")
        ("p" persp-prev "Prev"))
      "Buffers"
      (("b b" persp-counsel-switch-buffer "Switch to buffer in current perspective")
       ("b a" persp-add-buffer "Add buffer to current perspective")
       ("b k" persp-remove-buffer "Remove buffer from current perspective")
       ("b s" persp-set-buffer "Move buffer to current perspective"))
      "State Mgmt"
      (("w" persp-state-save "Write to disk")
       ("l" persp-state-load "Load from disk"))
    ))
   #+end_src

*** Buffers

   #+begin_src emacs-lisp
   (pretty-hydra-define geo/hydra-buffer-menu (:exit t :quit-key "q")
     ("Management"
       (("b" counsel-switch-buffer "Switch")
        ("n" evil-buffer-new "New")
        ("k" kill-this-buffer "Kill this buffer")
        ("K" geo/kill-other-buffers "Kill all other buffers"))
      "Views/Modes"
        (("i" ibuffer "ibuffer"))))
   ; (defhydra geo/hydra-buffer-menu (:exit t)
   ;   ("b" counsel-switch-buffer "Switch")
   ;   ("i" ibuffer "ibuffer"))
   #+end_src

*** Preferences

   #+begin_src emacs-lisp
   (pretty-hydra-define geo/hydra-prefs-menu (:quit-key "q")
     ("Basic"
       (("n" linum-mode "line number" :toggle t)
        ("w" whitespace-mode "whitespace" :toggle t)
        ("h" global-hl-line-mode "highlight line" :toggle t))
      "Editing"
       (("p" electric-pair-mode "electric-pair" :toggle t)
        ("d" diff-hl-mode "diff-hl" :toggle t)
        ("c" global-display-fill-column-indicator-mode :toggle t)
        (")" geo/toggle-show-paren-style "show-paren style"))
      "Modeline"
       (("m c" column-number-mode "column number" :toggle t))
    ))
   #+end_src

*** Projectile

    There's so much stuff in =projectile=. Who can keep track of it
    all? Now I don't have to!

    #+begin_src emacs-lisp
    (pretty-hydra-define geo/hydra-projectile (:exit t :quit-key "q")
      (
        "Files"
        (("f" projectile-find-file "Find file")
         (">" projectile-toggle-between-implementation-and-test
           "Go to test/impl")
         ("d" projectile-display-buffer "Display buffer")
         ("D" projectile-dired "dired"))

        "Searching"
        (("/" projectile-ag "ag")
         ("g" projectile-grep "grep")
         ("r" prejectile-ripgrep "ripgrep"))

        "Management"
        (("p" projectile-switch-project "Switch project")
         ("i" projectile-ibuffer "ibuffer")
         ("b" projectile-switch-to-buffer "Switch to buffer")
         ("t" projectile-test-project "Test project"))

        "Commands"
        (("v" projectile-run-vterm "vterm")
         ("c" projectile-run-command-in-root "Run command in root"))
    ))
    #+end_src

*** Dired

    Taken from the [[https://github.com/abo-abo/hydra/wiki/Dired][hydra wiki]]. Activate it with =.= in a =dired= mode.

    #+begin_src emacs-lisp
    (defhydra geo/hydra-dired (:hint nil :color pink)
"
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
    ("\\" dired-do-ispell)
    ("(" dired-hide-details-mode)
    (")" dired-omit-mode)
    ("+" dired-create-directory)
    ("=" diredp-ediff)         ;; smart diff
    ("?" dired-summary)
    ("$" diredp-hide-subdir-nomove)
    ("A" dired-do-find-regexp)
    ("C" dired-do-copy)        ;; Copy all marked files
    ("D" dired-do-delete)
    ("E" dired-mark-extension)
    ("e" dired-ediff-files)
    ("F" dired-do-find-marked-files)
    ("G" dired-do-chgrp)
    ("g" revert-buffer)        ;; read all directories again (refresh)
    ("i" dired-maybe-insert-subdir)
    ("l" dired-do-redisplay)   ;; relist the marked or singel directory
    ("M" dired-do-chmod)
    ("m" dired-mark)
    ("O" dired-display-file)
    ("o" dired-find-file-other-window)
    ("Q" dired-do-find-regexp-and-replace)
    ("R" dired-do-rename)
    ("r" dired-do-rsynch)
    ("S" dired-do-symlink)
    ("s" dired-sort-toggle-or-edit)
    ("t" dired-toggle-marks)
    ("U" dired-unmark-all-marks)
    ("u" dired-unmark)
    ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
    ("w" dired-kill-subdir)
    ("Y" dired-do-relsymlink)
    ("z" diredp-compress-this-file)
    ("Z" dired-do-compress)
    ("q" nil)
    ("." nil :color blue))

    (define-key dired-mode-map (kbd "?") 'geo/hydra-dired/body)
    #+end_src

*** Main

    My main hydra menu that provides help and direction. Sometimes I
    forget what to call or what keys to press. This helps immensely.

    #+begin_src emacs-lisp
    (pretty-hydra-define geo/hydra-top-menu
      (:title "The world's your oyster"
       :quit-key "q"
       :foreign-keys warn
       :exit t)
      ("Working"
       (("w" geo/hydra-workspace-menu/body "Workspaces")
        ("b" geo/hydra-buffer-menu/body "Buffers")
        ("p" geo/hydra-projectile/body "Projectile")
        ("g" magit-status "Magit"))

       "Getting Help"
       (("a" geo/hydra-apropos-menu/body "Apropos"))

       "Customizing"
       (("," geo/hydra-prefs-menu/body "Preferences"))))

    (define-key evil-normal-state-map (kbd "<SPC>") 'geo/hydra-top-menu/body)
    #+end_src


* Things to check out and eventually add

** Tabs

   - [[https://github.com/manateelazycat/awesome-tab][awesome-tab]]
   - [[https://github.com/ema2159/centaur-tabs][centaur-tabs]] - used by doom emacs

** UI

   - [[https://github.com/zk-phi/sublimity][sublimity]] - code minimap ala Sublime editor
   - [[https://github.com/emacsorphanage/anzu][anzu]] and [[https://github.com/emacsorphanage/evil-anzu][evil-anzu]] to display match count in the modeline
     (e.g. =(13/45)=)
   - [[https://github.com/joostkremers/writeroom-mode][writeroom-mode]] to change the editor into a distraction-free
     editor (for blog posts). [[https://gitlab.com/jabranham/mixed-pitch][mixed-pitch]] to display both variable-
     and fixed-width fonts at the same time would be a good companion.

** Apps within the app

   - [[https://github.com/ralesi/ranger.el][ranger]] - This is a minor mode that runs within dired, it emulates many
              of ranger's features. This minor mode shows a stack of parent
              directories, and updates the parent buffers, while you're navigating
              the file system. The preview window takes some of the ideas from
              Peep-Dired, to display previews for the selected files, in the
              primary dired buffer.
   - [[https://github.com/200ok-ch/counsel-jq][counsel-jq]] - use the =jq= json viewer through =counsel=

** Editor

   - [[https://github.com/iqbalansari/emacs-emojify][emojify]] - better (?) emoji support
   - [[https://github.com/abo-abo/auto-yasnippet][auto-yasnippet]] - create snippets on the go without and use them
     in-place. Kind of like temporary macros.

** Org Mode

   - [[https://github.com/zweifisch/ob-http][ob-http]] - make http requests in =org-mode=.
               Watch [[https://www.youtube.com/watch?v=tGgat6XJ2tk][Using org-mode as a rest client]] as a demo.


* References

  Helpful things I've found while researching configs.

  - [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs]] - categorized packages

  - https://jamiecollinson.com/blog/my-emacs-config/


* Disabled packages

  At one time or another, these were some packages I had installed. I
  have disabled them for various reasons. I'm keeping them around
  because I might enable them again at any time.

** =emacs-font-size=

   #+BEGIN_SRC emacs-lisp :tangle no
   (straight-use-package
     '(font-size :type git :host github :repo "nabeix/emacs-font-size")
     :config
     (font-size-init 18)
     (define-key global-map (kbd "C-=") 'font-size-increase))
   #+END_SRC

** =all-the-icons-ivy=

    Use *=all-the-icons-ivy=* to make it look prettier(?).
    Better? More graphical at least.

    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package all-the-icons-ivy
      :init
      (add-hook 'after-init-hook 'all-the-icons-ivy-setup))
    #+END_SRC

** =ivy-posframe=

    *ivy-posframe* lets ivy use posframe to show its menu.

    - [[https://github.com/tumashu/ivy-posframe][Github]]

    #+BEGIN_SRC emacs-lisp :tangle no
    (use-package ivy-posframe
      :straight t
      :after (ivy)
    #+END_SRC

** =flx=

     Use *=flx=* to provide some fuzzy matching.

     The default matcher will use a ~.*~ regex wild card in place of
     /each single space/ in the input. If you want to use the fuzzy
     matcher and use a ~.*~ regex wild card between /each input letter/,
     we config with fuzzy. From https://oremacs.com/2016/01/06/ivy-flx/.

     - [[https://github.com/lewang/flx][Github]]

     #+BEGIN_SRC emacs-lisp :tangle no
     (use-package flx
       :straight t
       :after (ivy counsel)
       :config
       (setq ivy-re-builders-alist
         '((ivy-switch-buffer . ivy--regex-plus)
           (t . ivy--regex-fuzzy))))
     #+END_SRC

** =emojify=

   *[DISABLED BECAUSE I DON'T THINK I NEED THIS]*
   *[if I ever enable this again, also check out [[https://github.com/dunn/company-emoji][company-emoji]]]*

   Emacs has pretty good support for emojis built-in. *emojify* makes it
   even better with ascii, unicode, and/or github style emoji support.

   - [[https://github.com/iqbalansari/emacs-emojify][Github]]

   #+BEGIN_SRC emacs-lisp :tangle no
   (use-package emojify
     :straight t
     :init
     ; only unicode and github (not ascii [ e.g. :-) ])
     (setq emojify-set-emoji-styles '(unicode github))
     ; by default emojis are shown as images; I prefer unicode
     (setq emojify-display-style 'unicode)
     :config
     (global-emojify-mode)
     )
   #+END_SRC

** Show line numbers in programming mode

    #+BEGIN_SRC emacs-lisp :tangle no
    (add-hook 'prog-mode-hook 'display-line-numbers-mode)
    #+END_SRC
